// oxlint-disable eslint/no-console

import fs from 'node:fs'
import { generateThemeCss } from './create-css-variables'

export type JsonType = Record<string, object | string>

type ThemeMatchType = {
  inputTheme: string
  palette: string
  outputTheme: string
}

type PaletteType = {
  shades: Record<string, ColorType>
  other: Record<string, ColorType>
  shadows: Record<string, ColorType>
  neutral: Record<string, ColorType>
  spacing: Record<string, ColorType>
}

type ThemeType = {
  unit: ColorType
  sizing: Record<string, ColorType>
  fontSize: Record<string, ColorType>
  lineHeight: Record<string, ColorType>
  color: Record<string, ColorType>
  typography: Record<string, ColorType>
  space: Record<string, ColorType>
  radii: Record<string, ColorType>
  breakpoints: Record<string, ColorType>
  boxShadow: Record<string, ColorType>
}

const themesMatches = [
  {
    inputTheme: 'productDarker',
    palette: 'paletteDarker',
    outputTheme: 'darker',
  },
  { inputTheme: 'productDark', palette: 'paletteDark', outputTheme: 'dark' },
  { inputTheme: 'productLight', palette: 'paletteLight', outputTheme: 'light' },
]

const hexColorRegex = /#(?:(?:[\da-f]{3}){1,2}(?:[\da-f]{2}){0,1})/gi

export const TOKENS_URL =
  'https://raw.githubusercontent.com/scaleway/design-tokens/main/tokens.json'

const header = `
/**
 * Provides all tokens of a specific theme edited by design team.
 * This file is automatically generated from utils/scripts/figma-synchronise-tokens.tsx.
 * PLEASE DO NOT EDIT HERE
 */\n`

type UvThemeType = {
  colors: Record<string, string>
  radii: Record<string, string>
  shadows: Record<string, string>
  space: Record<string, string>
  typography: Record<string, string>
  breakpoints: Record<string, string>
}

const createCSSFile = (theme: string, content: UvThemeType) => {
  const cssContent = generateThemeCss(content)
  const filePath = `packages/themes/public/style/${theme}.css`
  fs.writeFileSync(filePath, cssContent, 'utf8')
}

function alphaOrder(obj: JsonType) {
  const orderedKeys = Object.keys(obj ?? {}).sort()

  return orderedKeys.reduce((newObj: Record<string, string | object>, key) => {
    const result =
      typeof obj[key] === 'string' ? obj[key] : alphaOrder(obj[key] as JsonType)

    // eslint-disable-next-line no-param-reassign
    newObj[key] = result

    return newObj
  }, {})
}

type ShadowType = {
  x: string
  y: string
  blur: string
  spread: string
  color: string
  type: string
}

function isShadowType(
  data: ShadowType | Record<string, ShadowType>,
): data is ShadowType {
  return (
    data &&
    'x' in data &&
    'y' in data &&
    'blur' in data &&
    'spread' in data &&
    'color' in data
  )
}

function formatShadows(data: ShadowType | Record<string, ShadowType>) {
  if (isShadowType(data)) {
    return `${data.x}px ${data.y}px ${data.blur}px ${data.spread}px ${data.color}`
  }

  return Object.keys(data).reduce((acc: JsonType, key) => {
    acc[key] = formatShadows(data[key])

    return acc
  }, {})
}

function evalValue(value: string, variables: string | object) {
  if (typeof value === 'object') {
    return Object.keys(value).reduce(
      (acc: Record<string, string | object>, key) => {
        acc[key] = evalValue(value[key], variables)

        return acc
      },
      {},
    )
  }

  let returnedValue = value
  if (value.includes('$')) {
    const temp = value.replaceAll(/\$[a-zA-Z0-9\\.]+/g, match => {
      const keyParts = match.slice(1).split('.')

      let base = variables
      keyParts.forEach(key => {
        base = (base as Record<string, unknown>)[key] as string | object
      })

      return typeof base === 'string' ? base : JSON.stringify(base)
    })
    returnedValue = temp
  }

  return typeof returnedValue === 'string'
    ? returnedValue.replaceAll(hexColorRegex, match => match.toLowerCase())
    : returnedValue
}

type ColorType = {
  value: string
  type: string
}

function isColorType(
  data: ColorType | Record<string, ColorType> | ThemeType,
): data is ColorType {
  return data && 'value' in data && 'type' in data
}

function getValues(
  data: Record<string, ColorType> | ColorType | ThemeType,
  { typeFilter, variables }: { typeFilter: string; variables: JsonType },
) {
  if (isColorType(data)) {
    return data.type === typeFilter && 'value' in data
      ? evalValue(data.value, variables)
      : null
  }
  const res = Object.keys(data).reduce((values: JsonType, key) => {
    const newValue = getValues(
      (data as Record<string, ColorType | ThemeType>)[key],
      { typeFilter, variables },
    )

    if (newValue !== null) {
      // eslint-disable-next-line no-param-reassign
      values[key.replaceAll(/,/g, '.')] = newValue
    }

    return values
  }, {})

  return Object.keys(res).length > 0 ? res : null
}

export const generatePalette = (
  figmaTokensJson: JsonType,
  themeMatch: ThemeMatchType,
) => {
  const inputTheme = figmaTokensJson[themeMatch.inputTheme] as ThemeType
  const inputPalette = figmaTokensJson[themeMatch.palette] as PaletteType

  // Variable : unit
  // const unit = inputTheme.unit.value

  // Variable : palette shades
  const paletteShades = getValues(inputPalette.shades, {
    typeFilter: 'color',
    variables: {},
  })

  // Variable : palette other
  const paletteOther = getValues(inputPalette.other, {
    typeFilter: 'color',
    variables: {},
  })

  // Variable : palette shadows
  const paletteShadows = getValues(inputPalette.shadows, {
    typeFilter: 'color',
    variables: {},
  })

  // Variable : palette neutral
  const paletteNeutral = getValues(inputPalette.neutral, {
    typeFilter: 'color',
    variables: {
      shades: paletteShades ?? {},
    },
  })

  // Variable : theme space
  const sizing = getValues(inputTheme.sizing, {
    typeFilter: 'dimension',
    variables: {},
  })

  // Variable : theme fontSize
  const fontSize = getValues(inputTheme.fontSize, {
    typeFilter: 'fontSizes',
    variables: { sizing: sizing ?? {} },
  })

  console.log('fontSize generated')

  // Variable : theme lineHeights
  const lineHeight = getValues(inputTheme.lineHeight, {
    typeFilter: 'lineHeights',
    variables: { sizing: sizing ?? {} },
  })

  console.log('lineHeight generated')

  // Variable : theme color
  const colors = getValues(inputTheme, {
    typeFilter: 'color',
    variables: { shades: paletteShades ?? {}, other: paletteOther ?? {} },
  })

  console.log('colors generated')

  // Variable : theme shadows
  const shadows = getValues(inputTheme, {
    typeFilter: 'boxShadow',
    variables: {
      shades: paletteShades ?? {},
      shadows: paletteShadows ?? {},
      ...(typeof colors === 'object' ? colors : {}),
      other: paletteOther ?? {},
    },
  })

  console.log('shadows generated')

  // Variable : theme typography
  const typography = getValues(inputTheme, {
    typeFilter: 'typography',
    variables: {
      lineHeight: lineHeight ?? {},
      sizing: sizing ?? {},
      fontSize: fontSize ?? {},
    },
  })

  console.log('typography generated')

  // Variable : theme radii
  const radii = getValues(inputTheme.radii, {
    typeFilter: 'borderRadius',
    variables: { sizing: sizing ?? {} },
  })

  console.log('radii generated')

  // Variable : theme space
  const space = getValues(inputTheme.space, {
    typeFilter: 'dimension',
    variables: { sizing: sizing ?? {} },
  })

  console.log('space generated')

  const breakpoints = getValues(inputTheme.breakpoints, {
    typeFilter: 'dimension',
    variables: {},
  })

  console.log('breakpoints generated')

  const output = alphaOrder({
    colors: {
      ...(typeof colors === 'object' ? colors : {}),
      neutral: {
        ...(typeof colors === 'object' &&
        typeof colors?.['neutral'] === 'object'
          ? colors?.['neutral']
          : {}),
        ...(typeof paletteNeutral === 'object' ? paletteNeutral : {}),
      },
      overlay: getValues(inputPalette.other['overlay'], {
        typeFilter: 'color',
        variables: {},
      }),
    },
    radii: radii ?? {},
    shadows: formatShadows(shadows as ShadowType),
    space: space ?? {},
    sizing: sizing ?? {},
    theme: themeMatch.outputTheme,
    typography: typography ?? {},
    breakpoints: breakpoints ?? {},
  })

  return output
}

const writeFiles = async () => {
  const figmaTokensResponse: Response = await fetch(TOKENS_URL)
  const figmaTokensJson = (await figmaTokensResponse.json()) as JsonType

  // For each theme
  await Promise.all(
    themesMatches.map(async themeMatch => {
      const output = generatePalette(figmaTokensJson, themeMatch)
      const filePath = `packages/themes/src/themes/console/${themeMatch.outputTheme}/__generated__/index.ts`
      fs.writeFile(
        filePath,
        `${header}export const ${themeMatch.outputTheme}Theme = ${JSON.stringify(
          output,
        )}`,
        {},
        () => {
          console.log(`File written ${filePath}`)
        },
      )
      createCSSFile(themeMatch.outputTheme, output as UvThemeType) // Create CSS-tokens
    }),
  )
}
;(async () => {
  if (typeof process !== 'undefined' && process.versions?.node) {
    await writeFiles()
  }
})().catch(console.error)
