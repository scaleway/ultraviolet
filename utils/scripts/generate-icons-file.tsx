// oxlint-disable eslint/no-console
// biome-ignore-all lint/performance/useTopLevelRegex: error

import { existsSync, promises } from 'node:fs'
import path from 'node:path'
import { DEPRECATED_ICONS } from '../../packages/icons/src/deprecatedIcons'

const COMPONENTS = [
  {
    input: 'packages/icons/src/components/Icon/assets',
    name: 'System Icons',
    output: 'packages/icons/src/components/Icon/__generated__',
    suffix: 'Icon',
    typeName: 'SystemIconNames',
  },
  {
    input: 'packages/icons/src/components/ProductIcon/assets',
    name: 'Product Icons',
    output: 'packages/icons/src/components/ProductIcon/__generated__',
    suffix: 'ProductIcon',
    typeName: 'ProductIconNames',
  },
  {
    input: 'packages/icons/src/components/CategoryIcon/assets',
    name: 'Category Icons',
    output: 'packages/icons/src/components/CategoryIcon/__generated__',
    suffix: 'CategoryIcon',
    typeName: 'CategoryIconNames',
  },
  {
    input: 'packages/icons/src/components/Logo/assets',
    name: 'Logo',
    output: 'packages/icons/src/components/Logo/__generated__',
    suffix: 'Logo',
    typeName: 'LogoIconNames',
  },
  {
    input: 'packages/icons/src/components/Flags/assets',
    name: 'Flags',
    output: 'packages/icons/src/components/Flags/__generated__',
    suffix: 'Flag',
    typeName: 'FlagIconNames',
  },
]

const wrapSvg = (svgContent: string) => {
  const hasMultipleElements =
    svgContent.trim().split(/<path|<rect|<circle|<line|<ellipse|<g/).length > 2

  return hasMultipleElements ? `<>${svgContent}</>` : svgContent
}

const COMMENT_HEADER = `
  'use client'

  /**
* Provide the icon component for the icon name.
* This file is automatically generated from /utils/scripts/generate-icons-file.tsx.
* PLEASE DO NOT EDIT HERE
*/`

const templateIcon = (
  iconName: string,
  svg: string,
  svgSmall?: string,
  svgDisabled?: string,
) => {
  const deprecated = DEPRECATED_ICONS.find(icon => icon.name === iconName)

  return `${COMMENT_HEADER}
  import { Icon } from '../Icon'
  import type { IconProps } from '../Icon'

  ${
    deprecated
      ? `
  /**
    * @deprecated ${deprecated.deprecatedReason}
    */`
      : ''
  }
  ${
    svgSmall
      ? `export const ${iconName} = ({
    ...props
  }: Omit<IconProps, 'children'>) => (
      // eslint-disable-next-line react/jsx-props-no-spreading
      <Icon {...props}>{typeof props.size === 'string' && ['medium', 'large', 'xlarge', 'xxlarge'].includes(props.size) ? ${wrapSvg(svg)} : ${wrapSvg(svgSmall)}}</Icon>
  )`
      : `export const ${iconName} = ({
    ...props
  }: Omit<IconProps, 'children'>) => (
      // eslint-disable-next-line react/jsx-props-no-spreading
      <Icon {...props}>${svgDisabled ? `{props.disabled ? ${wrapSvg(svgDisabled)} : ${wrapSvg(svg)}}` : svg}</Icon>
  )`
  }

`
}

const toPascalCase = (str: string) =>
  str.replace(/(^\w|-\w)/g, match => match.replace('-', '').toUpperCase())

const generateVariableName = (filePath: string) => {
  const parsedPath = path.parse(filePath)
  const fileName = toPascalCase(parsedPath.name)
  const parentDir = path.basename(path.dirname(filePath))

  const isOutline = parentDir.includes('outline')
  const iconName = `${fileName}${isOutline ? 'Outline' : ''}`

  return iconName
}

const readDirectoryRecursive = async (dir: string) => {
  let results: string[] = []

  const list = await promises.readdir(dir, { withFileTypes: true })

  for (const file of list) {
    const filePath = path.resolve(dir, file.name)

    if (file.isDirectory()) {
      const subDirResults = await readDirectoryRecursive(filePath)
      results = [...results, ...subDirResults]
    } else if (path.extname(file.name).toLowerCase() === '.svg') {
      results.push(filePath)
    }
  }

  return results
}

const readSvg = async (filePath: string, suffix: string) => {
  const svgContent = await promises.readFile(filePath, 'utf8')
  const innerSvgContent = svgContent.replace(/<svg[^>]*>|<\/svg>/g, '') // Remove <svg ...> and </svg> tags

  // Replace class with className
  const updatedSvgContent = innerSvgContent
    .replace(/class=/g, 'className=')
    .replace(/fill-rule=/g, 'fillRule=')
    .replace(/fill-opacity=/g, 'fillOpacity=')
    .replace(/clip-rule=/g, 'clipRule=')
    .replace(/clip-path=/g, 'clipPath=')
    .replace(/stop-color=/g, 'stopColor=')
    .replace(/flood-opacity=/g, 'floodOpacity=')
    .replace(/stroke-width=/g, 'strokeWidth=')
    .replace(/stroke-linecap=/g, 'strokeLinecap=')
    .replace(/stroke-linejoin=/g, 'strokeLinejoin=')
    .replace(/stop-opacity=/g, 'stopOpacity=')
    .replace(/color-interpolation-filters=/g, 'colorInterpolationFilters=')
    .replace(/xlink:href=/g, 'xlinkHref=')
    .replace(/`/g, '\\`')
    .replace(/height="[^"]*"/g, '')
    .replace(/width="[^"]*"/g, '')

  if (suffix === 'Icon') {
    return updatedSvgContent.replaceAll(/fill="[^"]*"/g, '')
  }

  return updatedSvgContent
}

const appendExportToIndex = async (output: string, iconName: string) => {
  const exportStatement = `export { ${iconName} } from './${iconName}'\n`

  try {
    await promises.appendFile(`${output}/index.ts`, exportStatement)
  } catch (error) {
    console.error('Error appending to index file:', error)
  }
}

const appendTypeToIndex = async (
  output: string,
  typeName: string,
  iconNames: string[],
) => {
  const typeDefinition = `export type ${typeName} = ${iconNames.map(name => `"${name}"`).join(' | ')}\n`

  try {
    await promises.appendFile(`${output}/index.ts`, typeDefinition)
  } catch (error) {
    console.error('Error appending type to index file:', error)
  }
}

const resetIconsFolder = async (folderPath: string) => {
  try {
    const files = await promises.readdir(folderPath)
    const deletePromises = files.map(file =>
      promises.unlink(path.join(folderPath, file)),
    )
    await Promise.all(deletePromises)
    console.log(`Deleted all files in ${folderPath}`)
  } catch (error) {
    console.error('Error deleting files in icons folder:', error)
  }
}

const main = async () => {
  for (const component of COMPONENTS) {
    console.log(`Generating ${component.name}...`)
    await resetIconsFolder(component.output) // we clean the folder before generating the new icons

    try {
      await promises.appendFile(
        `${component.output}/index.ts`,
        `${COMMENT_HEADER}\n`,
      )
    } catch (error) {
      console.error('Error appending to index file:', error)
    }

    const iconNames: string[] = []

    try {
      const files = await readDirectoryRecursive(component.input)
      for (const file of files) {
        if (file.includes('small') || file.includes('disabled')) {
          break
        }

        const smallFileName = file.replace('default', 'small')
        const smallFile = existsSync(smallFileName) ? smallFileName : file

        const disabledFileName = file.replace('default', 'disabled')
        const disabledFile = existsSync(disabledFileName)
          ? disabledFileName
          : file

        const svgContent = await readSvg(file, component.suffix)
        const generatedName = `${generateVariableName(file)}${component.suffix}`

        iconNames.push(generatedName)

        const svgContentSmall =
          smallFile === file
            ? undefined
            : await readSvg(smallFile, component.suffix)

        const svgContentDisabled =
          component.name === 'Flags' && disabledFile !== file
            ? await readSvg(disabledFile, component.suffix)
            : undefined

        const generatedComponent = templateIcon(
          generatedName,
          svgContent,
          svgContentSmall,
          svgContentDisabled,
        )
        const filePath = `${component.output}/${generatedName}.tsx`

        try {
          await promises.writeFile(filePath, generatedComponent)
          console.log(`File has been written to ${filePath}`)
          await appendExportToIndex(component.output, generatedName)
        } catch (error) {
          console.error('Error writing to file:', error)
        }
      }

      // Append the type definition to the index file
      await appendTypeToIndex(component.output, component.typeName, iconNames)
    } catch (error) {
      console.error('Error reading directory:', error)
    }
  }
}

await main()
